{"meta":{"title":"切图仔","subtitle":"野生前端程序猿","description":"码农、爱思考、前端爱好者、穷折腾、三流程序员、二流切图仔","author":"Libo Shen","url":"http://mhcdk.com"},"pages":[{"title":"categories","date":"2018-01-12T09:02:52.856Z","updated":"2018-01-12T09:02:52.856Z","comments":true,"path":"categories/index.html","permalink":"http://mhcdk.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-09-16T08:06:13.000Z","updated":"2017-09-16T08:06:13.000Z","comments":true,"path":"tags/index.html","permalink":"http://mhcdk.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"weex学习日记：oh my zsh配置ANDROID_HOME的坑","slug":"android_home","date":"2018-01-29T08:28:00.000Z","updated":"2018-02-01T09:53:25.854Z","comments":true,"path":"2018/01/29/android_home/","link":"","permalink":"http://mhcdk.com/2018/01/29/android_home/","excerpt":"学习weex 启动weex run android 提示找不到$ANDROID_HOME 然后我已经在.bash_profile配置了，还是报错","text":"学习weex 启动weex run android 提示找不到$ANDROID_HOME 然后我已经在.bash_profile配置了，还是报错 年底项目暂时不多，抽出时间提升下自己，开始学习weex。 一些顺风顺水但是到安卓虚拟机准备跑项目的时候，提示报错找不到$ANDROID_HOME，然后去找解决方法 打开终端 open ~/.bash_profile 要是没有就创建一个 touch .bash_profile 添加以下代码在文件里 123export ANDROID_HOME=~/Library/Android/sdk#我的SDK是随着android studio一起下载的 所以路径在这里，不同下载方式不同路径，可以在设置里面查找export PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools 保存文件并关闭 更新下配置环境变量 1source .bash_profile 命令行输入adb看是否有东西输出，如果没有出现command not found的话就基本上完事儿了。 之后坑就来了，每当我新打开一个命令行窗口，或关闭，重启后发现配置失效，打开配置文件没毛病，百思不得其解google各种翻，最后确定是zsh的问题，真的是操了蛋了，最后解决方法是： 找到User目录下面的.zshrc文件,打开编辑器，在文件的末尾加上1source ~/.bash_profile 这样在每次启动zsh或新建一个窗口初始化的时候 就会更新下配置环境变量唯一不爽的是，配置的zsh输入提示颜色发生了点问题","categories":[{"name":"前端日记","slug":"前端日记","permalink":"http://mhcdk.com/categories/前端日记/"}],"tags":[{"name":"WEEX","slug":"WEEX","permalink":"http://mhcdk.com/tags/WEEX/"}]},{"title":"Safari浏览器 Cookie丢失字符的坑","slug":"safari_cookie","date":"2018-01-26T05:28:00.000Z","updated":"2018-02-01T09:52:30.925Z","comments":true,"path":"2018/01/26/safari_cookie/","link":"","permalink":"http://mhcdk.com/2018/01/26/safari_cookie/","excerpt":"记一次项目开发Safari Cookie无法储存汉字等字符的坑","text":"记一次项目开发Safari Cookie无法储存汉字等字符的坑 Safari浏览器不支持将非ASCII字符存入Cookie，所以中文在保存的时候就会出问题，分号(“;”)也不能存在Cookie中。所以需要通过方法去除内容中的分号，在Cookie保存非ASCII字符的时候需要通过UrlEncode / UrlDecode方法来编码和解码问题解决12document.cookie = `key=$&#123;encodeURI(JSON.stringify(value))&#125;;`const cookie = JSON.parse(decodeURI(document.cookie));","categories":[{"name":"前端日记","slug":"前端日记","permalink":"http://mhcdk.com/categories/前端日记/"}],"tags":[{"name":"Safari","slug":"Safari","permalink":"http://mhcdk.com/tags/Safari/"}]},{"title":"Vue内容分发 &lt;slot&gt; 的使用","slug":"Vue.solt","date":"2017-03-07T09:56:00.000Z","updated":"2018-02-01T09:51:24.281Z","comments":true,"path":"2017/03/07/Vue.solt/","link":"","permalink":"http://mhcdk.com/2017/03/07/Vue.solt/","excerpt":"官方文档对于这一块写的比较不好理解,也有点绕弯子.在这写一点个人的理解,和使用姿势…..","text":"官方文档对于这一块写的比较不好理解,也有点绕弯子.在这写一点个人的理解,和使用姿势….. 个人对内容分发&lt;slot&gt;的理解可以看做是 占位符、标签替换、插槽父组件中放入带有slot属性的内容，然后这些内容就会被分发到子组件中特殊的slot元素，根据name属性在子组件中重新组合、替换。123456789&lt;!--父组件--&gt;&lt;div id=\"parent\"&gt; &lt;child&gt; &lt;!--等待分发的内容--&gt; &lt;p slot=\"one\"&gt;一些内容&lt;/p&gt; &lt;p slot=\"two\"&gt;另外一些内容&lt;/p&gt; &lt;p&gt;不带slot属性的标签&lt;/p&gt; &lt;/child&gt;&lt;/div&gt; 1234567&lt;!--子组件--&gt;&lt;div id=\"child\"&gt; &lt;slot&gt;&lt;h1&gt;默认替换不带slot的元素&lt;/h1&gt;&lt;/slot&gt; &lt;slot name=\"one\"&gt;会被替换成父组件中slot=\"one\"的元素&lt;/slot&gt; &lt;slot name=\"two\"&gt;会被替换成父组件中slot=\"two\"的元素&lt;/slot&gt; &lt;p&gt;子组件自己的标签&lt;/p&gt;&lt;/div&gt; 最后会被渲染成:标签的顺序是根据子组件标签的顺序排列的,自行对照1234567&lt;div&gt; &lt;!--渲染后--&gt; &lt;p&gt;不带slot属性的标签&lt;/p&gt; &lt;p&gt;一些内容&lt;/p&gt; &lt;p&gt;另外一些内容&lt;/p&gt; &lt;p&gt;子组件自己的标签&lt;/p&gt;&lt;/div&gt; 如果父组件内没有那个不带slot属于的p标签, 则子组件内不带name属性的 &lt;slot&gt;会显示标签内的内容,没有标签包裹.1234567&lt;div&gt; &lt;!--渲染后--&gt; &lt;h1&gt;不带slot属性的标签&lt;/h1&gt; &lt;p&gt;一些内容&lt;/p&gt; &lt;p&gt;另外一些内容&lt;/p&gt; &lt;p&gt;子组件自己的标签&lt;/p&gt;&lt;/div&gt; slot就是外部调用时会被外部替换掉，如果外部没有内容则显示自己的内容; 2.1.0 新增了作用域插槽可以理解为，子组件可以将自己的数据发给父组件来处理123456789101112&lt;!--子组件--&gt;&lt;div id=\"child\"&gt; &lt;ul&gt; &lt;slot name=\"list\" v-for=\"val in arr\" :text=\"val\"&gt;&lt;/slot&gt; &lt;/ul&gt;&lt;/div&gt;data() &#123; return &#123; arr:[1,2,3] &#125;&#125; 12345678&lt;!--父组件--&gt;&lt;div id=\"parent\"&gt; &lt;Child&gt; &lt;template slot=\"list\" scope=\"props\"&gt; &lt;li&gt;&#123;&#123; props.text + 1 &#125;&#125;&lt;/li&gt; &lt;/template&gt; &lt;/Child&gt;&lt;/div&gt; 12345678&lt;!--最后渲染--&gt;&lt;div id=\"child\"&gt; &lt;ul&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;","categories":[{"name":"前端日记","slug":"前端日记","permalink":"http://mhcdk.com/categories/前端日记/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://mhcdk.com/tags/Vue/"}]},{"title":"Vue.directive自定义指令的使用","slug":"Vue.directive","date":"2017-03-03T10:16:00.000Z","updated":"2018-02-01T09:49:35.235Z","comments":true,"path":"2017/03/03/Vue.directive/","link":"","permalink":"http://mhcdk.com/2017/03/03/Vue.directive/","excerpt":"很多教程都是在讲自定义指令的概念和语法,看的相当蛋疼.本文不讲语法和概念,只讲用法.自定义指令基本就是用来操作DOM的,虽然官方推荐数据驱动视图,有时候还是需要自定义指令来操作DOM,指令可复用.","text":"很多教程都是在讲自定义指令的概念和语法,看的相当蛋疼.本文不讲语法和概念,只讲用法.自定义指令基本就是用来操作DOM的,虽然官方推荐数据驱动视图,有时候还是需要自定义指令来操作DOM,指令可复用. 1. 自定义指令实现拖拽1&lt;div v-drag&gt;我可以拖拽&lt;/div&gt; 12345678910111213141516Vue.directive('drag', inserted:function(el)&#123; //inserted 钩子函数:当元素被插入父元素时触发,可省略 let oDiv=el; //el --&gt; 触发的DOM元素 oDiv.onmousedown=function(e)&#123; let l=e.clientX-oDiv.offsetLeft; let t=e.clientY-oDiv.offsetTop; document.onmousemove=function(e)&#123; oDiv.style.left=e.clientX-l+'px'; oDiv.style.top=e.clientY-t+'px'; &#125;; oDiv.onmouseup=function()&#123; document.onmousemove=null; oDiv.onmouseup=null; &#125; &#125;&#125;) 自定义指令还可以引入第三方插件,之前都是用JQuery来构建项目. 自定义指令的好处就是不管之前是用什么写的JQuery还好或是原生js也好都可以直接拿来封装成自定义指令,不需要重写 例如这个拖拽:123456789101112131415161718192021222324Drag.js:export default function(el)&#123; let oDiv=el; oDiv.onmousedown=function(e)&#123; let l=e.clientX-oDiv.offsetLeft; let t=e.clientY-oDiv.offsetTop; document.onmousemove=function(e)&#123; oDiv.style.left=e.clientX-l+'px'; oDiv.style.top=e.clientY-t+'px'; &#125;; oDiv.onmouseup=function()&#123; document.onmousemove=null; oDiv.onmouseup=null; &#125; &#125;&#125;Vue:import drag from 'drag.js'Vue.directive('drag',drag)HTML: &lt;div v-drag&gt;我可以拖拽&lt;/div&gt; 2. 图片加载图片在加载过程中,未加载完成时,使用一个随机的颜色占位,图片加载完后直接显示,可以使用自定义指令来完成12345678910111213141516171819HTML: &lt;img v-imgUrl=\"url\"&gt;&lt;/img&gt; //参数不可以直接填写url地址 data () &#123; url:'src/assets/logo.png' &#125;Vue: Vue.directive('imgUrl',function(el,binding)&#123; var color=Math.floor(Math.random()*1000000);//设置随机颜色 el.style.backgroundColor='#'+color; var img=new Image(); img.src=binding.value;// --&gt;binding.value指的是指令后的参数 img.onload=function()&#123; el.style.backgroundColor=''; el.src=binding.value; &#125; &#125;) 可以使用lodash.js工具库vue更多的API整理–&gt;GO","categories":[{"name":"前端日记","slug":"前端日记","permalink":"http://mhcdk.com/categories/前端日记/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://mhcdk.com/tags/Vue/"}]},{"title":"CSS 0.5像素线","slug":"0.5border","date":"2017-03-03T09:56:00.000Z","updated":"2018-02-01T09:48:57.817Z","comments":true,"path":"2017/03/03/0.5border/","link":"","permalink":"http://mhcdk.com/2017/03/03/0.5border/","excerpt":"在移动端1像素的线是很丑的,而border-width设置为0.5px会被自动转成1px;border-width只能为自然数;类似的属性也不可以设置0.5;可以用伪元素+缩放来实现;","text":"在移动端1像素的线是很丑的,而border-width设置为0.5px会被自动转成1px;border-width只能为自然数;类似的属性也不可以设置0.5;可以用伪元素+缩放来实现; 123456789101112131415box&#123; position:relative; /*先给元素设置定位,除了static都可以*/&#125;.box1::before&#123; content: ''; /*追加一个空*/ position: absolute; /*设置定位*/ top: 0; /*如果不设置可能会出现偏移*/ left: 0; border: 1px solid #000; /*设置边框*/ width: 200%; /*设置为插入元素的两倍宽高*/ height: 200%; transform-origin: 0 0; /*设置元素的基点为0 0*/ transform: scale(0.5,0.5); /*宽高缩小一半*/ box-sizing: border-box; /*设置盒模型 这一步必须要有,否则边框不会随着一起缩放*/ &#125; 大概思路:想元素放大2倍但是1像素的边框仍是1像素,然后再缩放时,边框随着一起缩放一半,就形成0.5像素边框 这个方法低版本浏览器会有兼容问题； 如低版本安卓会出现transform属性不支持的情况 可使用 1234box&#123; border: 1px solid #ccc; border: thin solid #ccc;&#125; 属性thin的意思是细，比1px #ccc稍微颜色浅一点，看上去就像细了一样… 还可以使用阴影、背景颜色渐变等来实现 个人认为还是thin比较方便，懒人懒省事","categories":[{"name":"前端日记","slug":"前端日记","permalink":"http://mhcdk.com/categories/前端日记/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://mhcdk.com/tags/CSS/"}]},{"title":"各种For循环方法","slug":"EachFN","date":"2017-03-02T10:17:00.000Z","updated":"2018-02-01T09:48:17.774Z","comments":true,"path":"2017/03/02/EachFN/","link":"","permalink":"http://mhcdk.com/2017/03/02/EachFN/","excerpt":"小白时期搞什么都是For循环，敲的不亦乐乎。 然而数组Array遍历的方法有九种，面试时也多有被问到，所以分享给大家","text":"小白时期搞什么都是For循环，敲的不亦乐乎。 然而数组Array遍历的方法有九种，面试时也多有被问到，所以分享给大家 123456789101112// W3School : http://www.w3school.com.cn/jsref/jsref_obj_array.aspArray.indexOf();Array.lastIndexOf();Array.every();Array.some();Array.forEach();Array.map();Array.filter();Array.reduce();Array.reduceRight();for-of(ES6); 在开发中也非常实用，更高效的操作数组，本文适合新手在撸一遍，请大神轻拍。 1. Array.indexOf(); indexOf()方法返回在该数组中第一个找到的元素位置，如果它不存在则返回-1。 使用for：12345678910var arr = [ 'apple' , 'orange' , 'pear' ];var flag = false;for(var i = 0,l = arr.length; i&lt;l; i++)&#123; if(arr[i] === 'orange')&#123; flag = true; &#125;&#125;console.log(flag);//true 使用Array.indexOf():123456var arr = [ 'apple' , 'orange' , 'pear' ];var flag=arr.indexOf('orange');console.log(flag != -1);//true 2. Array.lastIndexOf(); 和indexOf一样,从后向前查询,indexOf是从前向后查询; 3. Array.every(); 检查数组中的每一项是否符合条件 使用for:123456789101112var arr=[1,2,3,4,-1,2];function every(arr)&#123; for(var i = 0,l = arr.length; i&lt;l; i++)&#123; if(arr[i] &lt; 0)&#123; return false &#125; return true &#125;&#125;console.log(every(arr))//false 使用Array.every():1234567var arr=[1,2,3,4,-1,2];var flag = arr.every(function(item, index)&#123; return item &gt; 0&#125;)console.log(flag)//false 4. Array.some();检查数组中的某一项是否符合条件 使用for:123456789101112var arr=[1,2,3,4,-1,2];function every(arr)&#123; for(var i = 0,l = arr.length; i&lt;l; i++)&#123; if(arr[i] &lt; 0)&#123; return true &#125; return false &#125;&#125;console.log(every(arr))//true 使用Array.some():1234567var arr=[1,2,3,4,-1,2];var flag = arr.some(function(item, index)&#123; return item &lt; 0&#125;)console.log(flag)//true 5. Array.forEach();遍历数组,代替for 使用for:123456789var arr = [1,2,3,4,5,6];for(var i = 0,l = arr.length; i &lt; l; i++)&#123; console.log(arr[i]); //1 //2 //3 //.....&#125; 使用Array.forEach():1234567var arr = [1,2,3,4,5,6];arr.forEach(function(val,index,arr)&#123; console.log(val);//1,2,3.... console.log(index);//下标 console.log(arr);//原数组&#125;) 6. Array.map();对数组进行操作,返回一个新数组,在处理服务器数据时经常使用 使用for:1234567891011var arr = [1,2,3,4,5,6];function map(arr)&#123; var arr2=[]; for(var i = 0,l = arr.length; i &lt; l; i++)&#123; arr2[i] = arr[i] + 1; &#125; return arr2;&#125;console.log(map(arr));//2,3,4,5,6,7 使用Array.map():123456var arr = [1,2,3,4,5,6];var arr2=arr.map(function(val,index)&#123; return val + 1&#125;)console.log(arr2)//2,3,4,5,6,7 map()和forEach()的区别:map()可以使用return返回一个新的数组,而forEach不可以使用return;return是返回一个修改的数组的副本,对原数组没有影响;两个都可以对第三个参数原数组进行修改,可以对原数组修改; 123456789var arr = [1,2,3,4];arr.forEach(function(val,index,arr)&#123; arr[index] = \"123\"&#125;)console.log(arr);// \"123\", \"123\", \"123\", \"123\", \"123\", \"123\" 7. Array.filter();返回一个新的匹配条件的数组 使用for:12345678910111213var arr = [1,2,3,4,5,-1];function filter(arr)&#123; var arr2 = []; for(var i = 0,j = arr.length; i++)&#123; if(arr[i] &lt; 0)&#123; arr2.push(arr[i]) &#125; &#125;&#125;console.log(filter(arr));//-1 使用Array.filter():12345678var arr = [1,2,3,4,5,-1];var arr2=arr.filter(function(val,index,arr)&#123; return val &lt; 0;&#125;)console.log(arr2);//-1 8. Array.reduce();接受一个回调函数作为累加器,最终返回一个值. arr.reduce(callback[, initialValue]) callback(回调函数,接收四个参数) previousValue(上次调用的回调函数的返回值,或初始值) currentValue(目前正在处理的函数元素) index(正在处理的元素下标) array(调用reduce方法的数组) initialValue(可选的初始值,作为第一次使用传给previousValue) 有点晦涩难懂,看案例吧 a). 求最大数:123456var arr = [1,2,3,4];var flag=arr.reduce(function(pre,cur,index,arr)&#123; return pre&gt;cur?pre:cur;&#125;)console.log(flag)//4 b). 求和:123456var arr = [1,2,3,4];var flag=arr.reduce(function(pre,cur,index,arr)&#123; return pre+cur&#125;)console.log(flag)//10 c). 乘积123456var arr = [1,2,3,4];var flag=arr.reduce(function(pre,cur,index,arr)&#123; return pre*cur&#125;)console.log(flag)//24 reduce就是为这种累加操作设计的,那么initialValue参数有什么用呢?我理解的是用来代替previousValue成为第一个参数12345678var arr = [1,2,3,4];var flag=arr.reduce(function(pre,cur,index,arr)&#123; return pre+cur&#125;,100)console.log(flag)//110 9. Array.reduceRight():用法和参数和reduce一样,不同的是reduce是升序,而reduceRight是降序 10. for-of循环(ES6): forEach好用但是不可以中断循环for-in可以遍历’enumerable’对象,不推荐用来遍历数组,数组的 index 跟普通的对象属性不一样，是重要的数值序列指标。 for-of是ES6引入的一种新方法,比普通for循环简单,也弥补了forEach和for-in的缺点123for (var value of myArray) &#123; console.log(value);&#125; for-of可以循环很多种数据类型(数组,对象,字符串等)","categories":[{"name":"前端日记","slug":"前端日记","permalink":"http://mhcdk.com/categories/前端日记/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://mhcdk.com/tags/JS/"}]}]}